diff --git a/node_modules/tsruntime/dist/transform/reflect.js b/node_modules/tsruntime/dist/transform/reflect.js
index bab6f8a..25005af 100644
--- a/node_modules/tsruntime/dist/transform/reflect.js
+++ b/node_modules/tsruntime/dist/transform/reflect.js
@@ -125,13 +125,28 @@ function getReflect(ctx) {
         }
         //@ts-ignore
         var nameType = symbol.nameType;
-        var nameSymb = nameType.getSymbol();
-        if (nameSymb) {
-            return nameSymb.valueDeclaration;
-        }
-        else {
-            //@ts-expect-error
-            return ts.factory.createLiteral(nameType.value);
+
+        // PATCH: Handle undefined nameType gracefully
+        if (!nameType) {
+            // console.warn('getPropertyName: nameType is undefined for symbol:', symbol.escapedName || symbol.name || 'unknown');
+            // Fallback: create identifier from symbol name
+            var symbolName = symbol.escapedName || symbol.name || 'unknown';
+            return ts.factory.createIdentifier(String(symbolName));
+        }
+
+        try {
+            var nameSymb = nameType.getSymbol();
+            if (nameSymb) {
+                return nameSymb.valueDeclaration;
+            }
+            else {
+                //@ts-expect-error
+                return ts.factory.createLiteral(nameType.value);
+            }
+        } catch (error) {
+            console.warn('getPropertyName: getSymbol() failed:', error.message);
+            var symbolName = symbol.escapedName || symbol.name || 'unknown';
+            return ts.factory.createIdentifier(String(symbolName));
         }
     }
     function serializeInitializer(decl) {
@@ -140,19 +155,36 @@ function getReflect(ctx) {
             : undefined;
     }
     function serializePropertySymbol(sym) {
-        var decl = sym.declarations[0];
-        var type = ctx.checker.getTypeOfSymbolAtLocation(sym, ctx.node);
-        var serializedType = reflectType(type);
-        var modifiers = ts.getCombinedModifierFlags(decl);
-        var name = getPropertyName(sym);
-        var initializer = ts.isPropertyDeclaration(sym.valueDeclaration)
-            ? serializeInitializer(sym.valueDeclaration)
-            : undefined;
-        return {
-            name: name,
-            modifiers: modifiers,
-            type: __assign(__assign({}, serializedType), { initializer: initializer }),
-        };
+        try {
+            var decl = sym.declarations[0];
+            var type = ctx.checker.getTypeOfSymbolAtLocation(sym, ctx.node);
+            var serializedType = reflectType(type);
+            var modifiers = ts.getCombinedModifierFlags(decl);
+            var name = getPropertyName(sym);
+
+            // Ensure serializedType has a valid kind property
+            if (!serializedType || typeof serializedType.kind === 'undefined') {
+                serializedType = { kind: types_1.TypeKind.Unknown2 };
+            }
+
+            var initializer = ts.isPropertyDeclaration(sym.valueDeclaration)
+                ? serializeInitializer(sym.valueDeclaration)
+                : undefined;
+            return {
+                name: name,
+                modifiers: modifiers,
+                type: __assign(__assign({}, serializedType), { initializer: initializer }),
+            };
+        } catch (error) {
+            // console.warn('serializePropertySymbol failed for symbol:', sym.escapedName || sym.name, error.message);
+            // Return a minimal fallback property
+            var symbolName = sym.escapedName || sym.name || 'unknown';
+            return {
+                name: ts.factory.createIdentifier(String(symbolName)),
+                modifiers: 0,
+                type: { kind: types_1.TypeKind.Unknown2 }
+            };
+        }
     }
     function serializeConstructorParameter(param) {
         var decl = param.declarations[0];
@@ -178,9 +210,17 @@ function getReflect(ctx) {
     }
     function serializeObjectType(type) {
         var symbol = type.getSymbol();
-        var properties = ctx.checker
-            .getPropertiesOfType(type)
-            .map(serializePropertySymbol);
+        var properties = [];
+
+        try {
+            properties = ctx.checker
+                .getPropertiesOfType(type)
+                .map(serializePropertySymbol)
+                .filter(function(prop) { return prop != null; }); // Filter out failed serializations
+        } catch (error) {
+            console.warn('serializeObjectType: Failed to get properties for type:', symbol ? symbol.getName() : 'unknown', error.message);
+        }
+
         var name;
         if (type.objectFlags & ts.ObjectFlags.Anonymous) {
             name = undefined;
@@ -217,64 +257,70 @@ function getReflect(ctx) {
         // return { kind: TypeKind.Unknown2 };
     }
     function reflectType(type) {
-        if (type.flags & ts.TypeFlags.Any) {
-            return { kind: types_1.TypeKind.Any };
-        }
-        else if (type.flags & ts.TypeFlags.StringLiteral) {
-            return {
-                kind: types_1.TypeKind.StringLiteral,
-                value: type.value
-            };
-        }
-        else if (type.flags & ts.TypeFlags.NumberLiteral) {
-            return {
-                kind: types_1.TypeKind.NumberLiteral,
-                value: type.value
-            };
-        }
-        else if (type.flags & ts.TypeFlags.String) {
-            return { kind: types_1.TypeKind.String };
-        }
-        else if (type.flags & ts.TypeFlags.Number) {
-            return { kind: types_1.TypeKind.Number };
-        }
-        else if (type.flags & ts.TypeFlags.Boolean) {
-            return { kind: types_1.TypeKind.Boolean };
-        }
-        else if (type.flags & ts.TypeFlags.BooleanLiteral) {
-            switch (type.intrinsicName) {
-                case "true":
-                    return { kind: types_1.TypeKind.TrueLiteral };
-                case "false":
-                    return { kind: types_1.TypeKind.FalseLiteral };
+        try {
+            if (type.flags & ts.TypeFlags.Any) {
+                return { kind: types_1.TypeKind.Any };
             }
+            else if (type.flags & ts.TypeFlags.StringLiteral) {
+                return {
+                    kind: types_1.TypeKind.StringLiteral,
+                    value: type.value
+                };
+            }
+            else if (type.flags & ts.TypeFlags.NumberLiteral) {
+                return {
+                    kind: types_1.TypeKind.NumberLiteral,
+                    value: type.value
+                };
+            }
+            else if (type.flags & ts.TypeFlags.String) {
+                return { kind: types_1.TypeKind.String };
+            }
+            else if (type.flags & ts.TypeFlags.Number) {
+                return { kind: types_1.TypeKind.Number };
+            }
+            else if (type.flags & ts.TypeFlags.Boolean) {
+                return { kind: types_1.TypeKind.Boolean };
+            }
+            else if (type.flags & ts.TypeFlags.BooleanLiteral) {
+                switch (type.intrinsicName) {
+                    case "true":
+                        return { kind: types_1.TypeKind.TrueLiteral };
+                    case "false":
+                        return { kind: types_1.TypeKind.FalseLiteral };
+                }
+            }
+            else if (type.flags & ts.TypeFlags.ESSymbol) {
+                return { kind: types_1.TypeKind.ESSymbol };
+            }
+            else if (type.flags & ts.TypeFlags.Void) {
+                return { kind: types_1.TypeKind.Void };
+            }
+            else if (type.flags & ts.TypeFlags.Undefined) {
+                return { kind: types_1.TypeKind.Undefined };
+            }
+            else if (type.flags & ts.TypeFlags.Null) {
+                return { kind: types_1.TypeKind.Null };
+            }
+            else if (type.flags & ts.TypeFlags.Never) {
+                return { kind: types_1.TypeKind.Never };
+            }
+            else if (type.flags & ts.TypeFlags.Unknown) {
+                return { kind: types_1.TypeKind.Unknown };
+            }
+            else if (type.flags & ts.TypeFlags.Object) {
+                return serializeObject(type);
+            }
+            else if (type.flags & ts.TypeFlags.Union) {
+                return serializeUnion(type);
+            }
+
+            ctx.reportUnknownType(type);
+            return { kind: types_1.TypeKind.Unknown2 };
+        } catch (error) {
+            console.warn('reflectType failed:', error.message);
+            return { kind: types_1.TypeKind.Unknown2 };
         }
-        else if (type.flags & ts.TypeFlags.ESSymbol) {
-            return { kind: types_1.TypeKind.ESSymbol };
-        }
-        else if (type.flags & ts.TypeFlags.Void) {
-            return { kind: types_1.TypeKind.Void };
-        }
-        else if (type.flags & ts.TypeFlags.Undefined) {
-            return { kind: types_1.TypeKind.Undefined };
-        }
-        else if (type.flags & ts.TypeFlags.Null) {
-            return { kind: types_1.TypeKind.Null };
-        }
-        else if (type.flags & ts.TypeFlags.Never) {
-            return { kind: types_1.TypeKind.Never };
-        }
-        else if (type.flags & ts.TypeFlags.Unknown) {
-            return { kind: types_1.TypeKind.Unknown };
-        }
-        else if (type.flags & ts.TypeFlags.Object) {
-            return serializeObject(type);
-        }
-        else if (type.flags & ts.TypeFlags.Union) {
-            return serializeUnion(type);
-        }
-        ctx.reportUnknownType(type);
-        return { kind: types_1.TypeKind.Unknown2 };
     }
     function reflectClass(type) {
         var base = type.getBaseTypes();
