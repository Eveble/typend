(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{148:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return c}));var r=n(2),a=n(9),i=(n(0),n(290)),o={title:"Creating Utility",sidebar_label:"Creating Utility"},l={id:"guides/04-advanced/04-creating-utility",title:"Creating Utility",description:"Utilities are special kind of concept that allows by very hacky way of implementing Utility Types a-like types for validation. Currently, tsruntime does not implement reflection of TypeScript's Utility Types, however simple generics structures are supported.",source:"@site/docs/guides/04-advanced/04-creating-utility.md",permalink:"/typend/docs/guides/04-advanced/04-creating-utility",sidebar_label:"Creating Utility",sidebar:"guides",previous:{title:"Creating Pattern",permalink:"/typend/docs/guides/04-advanced/03-creating-pattern"}},p=[],s={rightToc:p};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Utilities are special kind of concept that allows by very hacky way of implementing ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.typescriptlang.org/docs/handbook/utility-types.html"}),"Utility Types")," a-like types for validation. Currently, ",Object(i.b)("inlineCode",{parentName:"p"},"tsruntime")," does not implement reflection of TypeScript's Utility Types, however simple generics structures are supported."),Object(i.b)("p",null,"We (",Object(i.b)("em",{parentName:"p"},"ab"),")use this to create objects, that serves a purpose of container that hold their ",Object(i.b)("strong",{parentName:"p"},"utility type")," and ",Object(i.b)("strong",{parentName:"p"},"payload"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"export type $PropsOf<T> = {\n  __eveble_validation: 'propertiesOf';\n  __eveble_payload: T;\n};\n")),Object(i.b)("p",null,"So when we use:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"check<$PropsOf<MyClass>>();\n")),Object(i.b)("p",null,"The class constructor becomes the payload."),Object(i.b)("p",null,"Please fallow this guide when defining new generic utility types:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Use PascalCase with ",Object(i.b)("inlineCode",{parentName:"li"},"$")," prefix for naming of types so they are not mistaken as native build-inTypeScript types:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"good"),": ",Object(i.b)("inlineCode",{parentName:"li"},"$PropsOf"),", ",Object(i.b)("inlineCode",{parentName:"li"},"$Range"),", ",Object(i.b)("inlineCode",{parentName:"li"},"$Length"),", ",Object(i.b)("inlineCode",{parentName:"li"},"$MyValidationType")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"bad"),": ",Object(i.b)("inlineCode",{parentName:"li"},"Extract"),", ",Object(i.b)("inlineCode",{parentName:"li"},"Omit"),", ",Object(i.b)("inlineCode",{parentName:"li"},"MyValidationType"),", ",Object(i.b)("inlineCode",{parentName:"li"},"propsOf"),", ",Object(i.b)("inlineCode",{parentName:"li"},"range"))),Object(i.b)("ol",{start:2},Object(i.b)("li",{parentName:"ol"},"USE snake_case for property key."),Object(i.b)("li",{parentName:"ol"},"DO NOT use any other characters(?) beside underscore and alphanumeric(?)."),Object(i.b)("li",{parentName:"ol"},"DO NOT use imported KEYS from other files as symbols or strings do to compilation errors:")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { VALIDATION_TYPE_PROPS_OF_KEY } from './constants/literal-keys';\nexport type propsOf<T> = {\n  [VALIDATION_TYPE_PROPS_OF_KEY]: T;\n};\n")),Object(i.b)("p",null,"Would result in:"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"ReferenceError: literal_keys_1 is not defined 'literal_keys_1' - this references the name of the file.")),Object(i.b)("p",null,"Now, since this generic type is reflected as object by ",Object(i.b)("inlineCode",{parentName:"p"},"tsruntime"),"(",Object(i.b)("inlineCode",{parentName:"p"},"kind: 15"),") we need to create additional converter:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { Types as tsruntimeTypes } from 'tsruntime';\nimport { types, LITERAL_KEYS } from 'typend';\n\nexport class PropsOfConverter implements types.TypeConverter {\n  isConvertible(\n  reflectedType: tsruntimeTypes.ReflectedType,\n  converter: types.Converter\n  ): boolean {\n    if (reflectedType.kind !== 15) {\n      return false;\n    }\n\n    const validationType = get(\n      reflectedType,\n      `properties.${LITERAL_KEYS.VALIDATION_TYPE_KEY.toString()}`\n    );\n    if (validationType?.value === LITERAL_KEYS.KINDS.PROPERTIES_OF) {\n      return false;\n    }\n\n    const validationPayload = get(\n      reflectedType,\n      `properties.${LITERAL_KEYS.VALIDATION_PAYLOAD_KEY.toString()}`\n    );\n    const classConverter = converter.getConverter(\n      LITERAL_KEYS.KINDS.CLASS\n    ) as types.TypeConverter;\n    return classConverter.isConvertible(validationPayload, converter);\n  }\n  ...\n}\n")),Object(i.b)("p",null,"First, we ensure that ",Object(i.b)("inlineCode",{parentName:"p"},"kind")," of ",Object(i.b)("inlineCode",{parentName:"p"},"reflectedType")," is pointing out to object(i.e. the number ",Object(i.b)("inlineCode",{parentName:"p"},"15"),") and ",Object(i.b)("inlineCode",{parentName:"p"},"validationType")," is indeed set to whatever value we assigned it previously under ",Object(i.b)("inlineCode",{parentName:"p"},"__eveble_validation")," on our generic ",Object(i.b)("inlineCode",{parentName:"p"},"$PropsOf")," type."),Object(i.b)("p",null,"Then, we ensure that our payload can be converted by class converter - since the purpose of ",Object(i.b)("inlineCode",{parentName:"p"},"$PropsOf")," utility is to generate pattern - that will allow for validation of required properties for class construction."),Object(i.b)("p",null,"Next, we need to implement ",Object(i.b)("inlineCode",{parentName:"p"},"convert")," methods on our ",Object(i.b)("inlineCode",{parentName:"p"},"PropsOfConverter"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { Types as tsruntimeTypes } from 'tsruntime';\nimport { types, LITERAL_KEYS, Class, Collection } from 'typend';\n\nexport class PropsOfConverter implements types.TypeConverter {\n  ...\n  convert(\n    reflectedType: tsruntimeTypes.ReflectedType,\n    converter: types.Converter\n  ): Collection {\n    const nestedReflectedType = get(\n      reflectedType,\n      `properties.${LITERAL_KEYS.VALIDATION_PAYLOAD_KEY.toString()}`\n    );\n\n    const classConverter = converter.getConverter(\n      LITERAL_KEYS.KINDS.CLASS\n    ) as types.TypeConverter;\n    const classType: Class | undefined = classConverter.convert(\n      nestedReflectedType,\n      converter\n    ) as Class;\n    const properties = classType !== undefined ? classType.properties : {};\n    return new Collection({ ...properties });\n  ...\n}\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"tsruntime")," by default will reflect nested structures to their own reflected types, so we resolve ",Object(i.b)("inlineCode",{parentName:"p"},"TypeConverter")," for ",Object(i.b)("inlineCode",{parentName:"p"},"class")," from our ",Object(i.b)("inlineCode",{parentName:"p"},"converter")," and pass that reflected type for conversion."),Object(i.b)("p",null,"Class converter will return ",Object(i.b)("inlineCode",{parentName:"p"},"Class")," pattern with assigned properties: ",Object(i.b)("inlineCode",{parentName:"p"},"type")," as provided class constructor and ",Object(i.b)("inlineCode",{parentName:"p"},"properties")," as the class definition. Since we are interested only with ",Object(i.b)("inlineCode",{parentName:"p"},"properties")," - we return that in form of new ",Object(i.b)("inlineCode",{parentName:"p"},"Collection")," pattern."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"TypeConverter")," additionally also requires ",Object(i.b)("inlineCode",{parentName:"p"},"reflect")," to method to be implemented so we do exactly that:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { Types as tsruntimeTypes } from 'tsruntime';\nimport { types, LITERAL_KEYS } from 'typend';\n\nexport class PropsOfConverter implements types.TypeConverter {\n  ...\n  reflect(\n    reflectedType: tsruntimeTypes.ReflectedType,\n    converter: types.Converter\n  ): Record<keyof any, any> {\n    const nestedReflectedType = get(\n      reflectedType,\n      `properties.${LITERAL_KEYS.VALIDATION_PAYLOAD_KEY.toString()}`\n    );\n\n    const classConverter = converter.getConverter(\n      LITERAL_KEYS.KINDS.CLASS\n    ) as types.TypeConverter;\n    return classConverter.reflect(nestedReflectedType, converter);\n  ...\n}\n")),Object(i.b)("p",null,"Having ",Object(i.b)("strong",{parentName:"p"},"utility type")," and ",Object(i.b)("inlineCode",{parentName:"p"},"TypeConverter")," is enough to start building validator - however, if you intend to support also JavaScript validation creating new ",Object(i.b)("inlineCode",{parentName:"p"},"Utility")," is necessary:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { WrapperPattern, types, Collection } from 'typend';\nimport { isClass } from '@eveble/helpers';\n\nexport class PropsOf extends WrapperPattern implements types.Utility {\n\n  constructor(type: any) {\n    if (!isClass(type)) {\n      throw new InvalidTypeError(\n        `PropsOf type is invalid. Expected type to be class, got ${Utility.describer.describe(\n          type\n        )}`\n      );\n    }\n    // Can't put negative numbers on construction.\n    // https://airbrake.io/blog/javascript-error-handling/rangeerror-invalid-array-length\n    super();\n    this.push(type);\n  }\n  ...\n}\n")),Object(i.b)("p",null,"We use ",Object(i.b)("inlineCode",{parentName:"p"},"WrapperPattern")," as our base class so our structures are easier to debug. We validate that provided type on construction is indeed a class type and assign it on 0 index."),Object(i.b)("p",null,"Utilities(",Object(i.b)("inlineCode",{parentName:"p"},"types.Utility"),") for JavasScript require ",Object(i.b)("inlineCode",{parentName:"p"},"generate")," method to be implemented that should return the expectation for validation. You can use whole ",Object(i.b)("strong",{parentName:"p"},"Typend")," features on generation:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { WrapperPattern, types, Collection } from 'typend';\nimport { isClass } from '@eveble/helpers';\n\nexport class PropsOf extends Array implements types.Utility {\n  ...\n  public generate(library: types.Library): Collection {\n    const type = this[0];\n    const classType: Class = library.converter.convert(type) as Class;\n    // Unwrap from Class pattern so properties are only validated and not matching type\n    return new Collection({ ...classType.properties });\n  }\n}\n")),Object(i.b)("p",null,"Again, we resolve class type converter implementing ",Object(i.b)("inlineCode",{parentName:"p"},"TypeConverter")," and return class properties as ",Object(i.b)("inlineCode",{parentName:"p"},"Collection")," pattern."),Object(i.b)("p",null,"Since we allowed class instance values on ",Object(i.b)("inlineCode",{parentName:"p"},"CollectionValidator"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"export class CollectionValidator extends PatternValidator\n  implements types.PatternValidator {\n  public validate(\n    value: any,\n    collOrExpect: Collection | Record<keyof any, any>,\n    validator: types.Validator\n  ): boolean {\n    if (!isClassInstance(value) && !isPlainObject(value)) {\n      throw new InvalidTypeError(\n        'Expected %s to be an Object',\n        this.describe(value)\n      );\n    }\n  ...\n  }\n}\n")),Object(i.b)("p",null,"Our ",Object(i.b)("inlineCode",{parentName:"p"},"$PropsOf"),"(TS) and ",Object(i.b)("inlineCode",{parentName:"p"},"PropsOf"),"(JS) will use already existing validator without necessity of implementing our own."),Object(i.b)("p",null,"Of course on ",Object(i.b)("inlineCode",{parentName:"p"},"PropsOfConverter")," and ",Object(i.b)("inlineCode",{parentName:"p"},"PropsOf")," utility we can always return a new, not-existing ",Object(i.b)("inlineCode",{parentName:"p"},"Pattern")," implementation and dedicate a new ",Object(i.b)("inlineCode",{parentName:"p"},"PatternValidator")," for handling it."))}c.isMDXComponent=!0},290:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return y}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),c=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},b=function(e){var t=c(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),b=c(n),u=r,y=b["".concat(o,".").concat(u)]||b[u]||d[u]||i;return n?a.a.createElement(y,l(l({ref:t},s),{},{components:n})):a.a.createElement(y,l({ref:t},s))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);