(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{141:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return o}));var n=a(2),r=a(9),i=(a(0),a(290)),c={title:"Validation",sidebar_label:"Validation"},b={id:"guides/02-usage/01-validation",title:"Validation",description:"TypeScript API",source:"@site/docs/guides/02-usage/01-validation.md",permalink:"/typend/docs/guides/02-usage/01-validation",sidebar_label:"Validation",sidebar:"guides",previous:{title:"Introduction",permalink:"/typend/docs/guides/02-usage/01-introduction"},next:{title:"Evaluation",permalink:"/typend/docs/guides/02-usage/02-evaluation"}},l=[{value:"TypeScript API",id:"typescript-api",children:[{value:"check",id:"check",children:[]}]},{value:"JavaScript API",id:"javascript-api",children:[{value:"validate",id:"validate",children:[]}]},{value:"Types of expectations",id:"types-of-expectations",children:[]}],p={rightToc:l};function o(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"typescript-api"},"TypeScript API"),Object(i.b)("p",null,"Validates if provided value matches \u2264T\u2265."),Object(i.b)("h3",{id:"check"},"check"),Object(i.b)("p",null,"\u25b8 ",Object(i.b)("strong",{parentName:"p"},"check\u2264T\u2265"),"(",Object(i.b)("inlineCode",{parentName:"p"},"value"),": any, ",Object(i.b)("inlineCode",{parentName:"p"},"isStrict"),"?: boolean): ",Object(i.b)("em",{parentName:"p"},"boolean")),Object(i.b)("p",null,"Validates if a value matches an expectation. ",Object(i.b)("inlineCode",{parentName:"p"},"check")," on values matching expectation will return ",Object(i.b)("inlineCode",{parentName:"p"},"true"),", else will throw."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"throws"))," {ValidationError}\nThrown if the value does not match expectation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Parameters:")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"value")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"any"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Value that needs to validated.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"isStrict")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"boolean"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Flag indicating that evaluation should be done in strict mode.")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns:")," ",Object(i.b)("em",{parentName:"p"},"boolean")),Object(i.b)("p",null,"Returns ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if validation is successful, else throws."),Object(i.b)("hr",null),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { expect } from 'chai';\nimport { check, UnmatchedTypeError } from 'typend';\n\nexpect(check<string>('im-a-string')).to.be.true;\nexpect(() => check<number>('im-not-a-number')).to.throw(\n  UnmatchedTypeError,\n  `Expected String(\"im-not-a-number\") to be a Number`\n);\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"check")," throws one of available and matching errors extending ",Object(i.b)("inlineCode",{parentName:"p"},"ValidationError"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"InvalidTypeError\nInvalidValueError\nUnequalValueError\nUnmatchedTypeError\nNotAMemberError\nUnexpectedKeyError\nUnknownError\n")),Object(i.b)("p",null,"You can use error's type(",Object(i.b)("inlineCode",{parentName:"p"},"UnmatchedTypeError"),") and message(",Object(i.b)("inlineCode",{parentName:"p"},'Expected String("im-not-a-number") to be a Number'),") to ensure in your tests that specific error was thrown and provided value is in fact invalid."),Object(i.b)("p",null,"You can learn more about ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../guides/03-patterns/01-introduction#expectations"}),"expectations, strict vs loose validation as patterns below"),"."),Object(i.b)("h2",{id:"javascript-api"},"JavaScript API"),Object(i.b)("p",null,"Native API allows to use all features that JavaScript provides without any limitation that TypeScript declaration notation is enforcing. This allows equality comparable validation on values that are instances of classes like:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { validate } from 'typend';\n\nvalidate(\n  new Date('December 17, 1995 03:24:00'),\n  new Date('December 17, 1995 03:24:00')\n);\n")),Object(i.b)("p",null,"or even regular expressions:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { validate } from 'typend';\n\nvalidate('foo', /foo/);\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Its important to understand that JavaScripts API is exposed on TypeScript environment so it can be used on limiting validation scenarios.")),Object(i.b)("hr",null),Object(i.b)("h3",{id:"validate"},"validate"),Object(i.b)("p",null,"\u25b8 ",Object(i.b)("strong",{parentName:"p"},"validate"),"(",Object(i.b)("inlineCode",{parentName:"p"},"value"),": any, ",Object(i.b)("inlineCode",{parentName:"p"},"expectation"),": ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../modules/types.md#expectation"}),"Expectation")," | ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"utility.md"}),"Utility"),", ",Object(i.b)("inlineCode",{parentName:"p"},"isStrict?"),": boolean): ",Object(i.b)("em",{parentName:"p"},"boolean")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Implementation of ",Object(i.b)("a",Object(n.a)({parentName:"em"},{href:"../../interfaces/types.library.md"}),"Library"))),Object(i.b)("p",null,"Validates if a value matches an expectation or throws."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"throws"))," {ValidationError}\nThrown if the value does not match provided expectation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Parameters:")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"value")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"any"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Value that needs to validated.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"expectation")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"../../modules/types.md#expectation"}),"Expectation")," ","|"," ",Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"../../api/classes/..utility.md"}),"Utility")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Expectation as explicit ",Object(i.b)("inlineCode",{parentName:"td"},"Pattern")," instance, instance of ",Object(i.b)("inlineCode",{parentName:"td"},"Utility")," or implicit expectation against which value will be validated.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"isStrict?")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"boolean"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Flag indicating that evaluation should be done in strict mode.")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns:")," ",Object(i.b)("em",{parentName:"p"},"boolean")),Object(i.b)("p",null,"Returns ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if validation is successful, else throws."),Object(i.b)("hr",null),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"validate")," on values matching expectation will return ",Object(i.b)("inlineCode",{parentName:"p"},"true"),", else will throw one of available and matching errors extending ",Object(i.b)("inlineCode",{parentName:"p"},"ValidationError"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"InvalidTypeError\nInvalidValueError\nUnequalValueError\nUnmatchedTypeError\nNotAMemberError\nUnexpectedKeyError\nUnknownError\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { expect } from 'chai';\nimport { validate, UnmatchedTypeError } from 'typend';\n\nexpect(validate('im-a-string', String)).to.be.true;\nexpect(() => validate('im-not-a-number', Number)).to.throw(\n  UnmatchedTypeError,\n  `Expected String(\"im-not-a-number\") to be a Number`\n);\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { expect } from 'chai';\nimport { define, validate, propsOf, UnequalValueError } from 'typend';\n\n@define()\nclass Unicorn {\n  sentence: 'sparkle';\n\n  constructor(sentence: 'sparkle') {\n    validate({ sentence }, propsOf(Unicorn));\n    this.sentence = sentence;\n  }\n}\nexpect(() => new Unicorn('\ud83e\udd84\ud83e\udd84 Charrlieee! \ud83c\udf4c\ud83d\udc51' as any)).to.throw(\n  UnequalValueError\n);\n")),Object(i.b)("p",null,"You can learn more about ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../guides/03-patterns/01-introduction#expectations"}),"expectations, strict vs loose evaluation as patterns below"),"."),Object(i.b)("h2",{id:"types-of-expectations"},"Types of expectations"),Object(i.b)("p",null,"Typend uses 3 types of expectations to validate provided value:"),Object(i.b)("h4",{id:"1-implicit---any-passed-argument-thats-used-as-expectation"},"1. Implicit - ",Object(i.b)("em",{parentName:"h4"},"Any passed argument thats used as expectation")),Object(i.b)("p",null,"We call them ",Object(i.b)("em",{parentName:"p"},"implicit")," expectations since ",Object(i.b)("strong",{parentName:"p"},"typend")," must evaluate what validation type should be used. Any provided argument can be used as implicit expectation. ",Object(i.b)("strong",{parentName:"p"},"Typend")," will try evaluate the best possible validator for provided argument(however that comes with performance impact). By that we mean, if value, expectations are:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"value"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"expectation"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"typend assumption"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"foo")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"string")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"evaluate ",Object(i.b)("inlineCode",{parentName:"td"},"foo")," to be instanceOf a ",Object(i.b)("inlineCode",{parentName:"td"},"String"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"12")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"number")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"evaluate ",Object(i.b)("inlineCode",{parentName:"td"},"12")," to be instanceOf a ",Object(i.b)("inlineCode",{parentName:"td"},"Number"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"new Person({name: 'Jane Doe'})")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"Person")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"evaluate ",Object(i.b)("inlineCode",{parentName:"td"},"Person")," instance to be instanceOf a class ",Object(i.b)("inlineCode",{parentName:"td"},"Person"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"foo")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"foo")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"evaluate ",Object(i.b)("inlineCode",{parentName:"td"},"foo")," to be equal ",Object(i.b)("inlineCode",{parentName:"td"},"foo"))))),Object(i.b)("p",null,"etc."),Object(i.b)("p",null,"Implicit patterns are the core of ",Object(i.b)("strong",{parentName:"p"},"typend's")," support for TypeScript declarations."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"In more OOP/DDD friendly environments where most of validation is done on class construction level - the performance impact is less the case since we cache the type's definition.")),Object(i.b)("h4",{id:"2-explicit---pattern"},"2. Explicit - ",Object(i.b)("inlineCode",{parentName:"h4"},"Pattern")),Object(i.b)("p",null,"Those are the most efficient way to validate value against specific ",Object(i.b)("inlineCode",{parentName:"p"},"Pattern"),". They remove the guess work that ",Object(i.b)("em",{parentName:"p"},"implicit")," validation is burden with."),Object(i.b)("p",null,"They are the base building blocks of validation - they are used to ",Object(i.b)("em",{parentName:"p"},"explicitly")," tell ",Object(i.b)("strong",{parentName:"p"},"Typend")," to which validator(",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../api/interfaces/types.patternvalidator"}),"PatternValidator"),") delegate the validation."),Object(i.b)("p",null,"Pattern classes must implement ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../api/interfaces/types.pattern"}),"Pattern")," interface, and with that - implement ",Object(i.b)("inlineCode",{parentName:"p"},"getKind(): string")," method which returns the ",Object(i.b)("em",{parentName:"p"},"validator kind"),"(used as identifier)."),Object(i.b)("p",null,"Returned ",Object(i.b)("inlineCode",{parentName:"p"},"string")," from the method is used to find explicit validator that can evaluate value without using performance-impacting if-else statements(in comparison to using ",Object(i.b)("em",{parentName:"p"},"any passed expectation")," as ",Object(i.b)("em",{parentName:"p"},"implicit")," expectation)."),Object(i.b)("p",null,"By example:"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"List")," pattern as defined ",Object(i.b)("inlineCode",{parentName:"p"},"kind")," uses ",Object(i.b)("inlineCode",{parentName:"p"},"LITERAL_KEYS.KINDS.ARRAY"),". ",Object(i.b)("strong",{parentName:"p"},"Typend")," has already registered validator for that type as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../api/classes/listvalidator"}),"ListValidator")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"export class List extends Array implements types.Pattern {\n  public static kind = KINDS.ARRAY;\n  ...\n  public getKind(): string {\n    return (this.constructor as types.PatternType).kind;\n  }\n}\n")),Object(i.b)("p",null,"You can learn more about defining your own ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../guides/04-advanced/03-creating-pattern"}),"patterns and validators")),Object(i.b)("h4",{id:"3-utilities"},"3. Utilities"),Object(i.b)("p",null,"They are generators of ",Object(i.b)("em",{parentName:"p"},"explicit")," expectations."),Object(i.b)("p",null,"Currently supported by:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"$TypeOf<T>")," - as ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"../../api/classes/typeof"}),"TypeOf")," pattern"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"$PropsOf<T>")," - as ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"../../api/classes/propsof"}),"PropsOf")," pattern")),Object(i.b)("p",null,"Utilities are special types using generic notation prefixed with ",Object(i.b)("inlineCode",{parentName:"p"},"$")," symbol. They are responsible for additional ",Object(i.b)("em",{parentName:"p"},"conversion")," of type(",Object(i.b)("inlineCode",{parentName:"p"},"T"),") to validable-form and creation of a specific, applicable pattern for validation that are containing converted result."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { define, check } from 'typend';\n\n@define()\nclass MyClass {\n  key: string;\n\n  constructor(key: string) {\n    this.key = key;\n  }\n}\nconst myClass = new MyClass('my-string');\n\nexpect(check<$TypeOf<MyClass>>(myClass)).to.be.true;\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"import { expect } from 'chai';\nimport { define, check, UnequalValueError, PropsOf } from 'typend';\n\n@define()\nclass Unicorn {\n  sentence: 'sparkle';\n\n  constructor(sentence: 'sparkle') {\n    check<PropsOf<Unicorn>>({sentence});\n    this.sentence = sentence;\n  }\n}\nexpect(() => new Unicorn('\ud83e\udd84\ud83e\udd84 Charrlieee! \ud83c\udf4c\ud83d\udc51').to.throw(\n  UnequalValueError\n);\n")))}o.isMDXComponent=!0},290:function(e,t,a){"use strict";a.d(t,"a",(function(){return s})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=r.a.createContext({}),o=function(e){var t=r.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},s=function(e){var t=o(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),s=o(a),m=n,u=s["".concat(c,".").concat(m)]||s[m]||d[m]||i;return a?r.a.createElement(u,b(b({ref:t},p),{},{components:a})):r.a.createElement(u,b({ref:t},p))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,c=new Array(i);c[0]=m;var b={};for(var l in t)hasOwnProperty.call(t,l)&&(b[l]=t[l]);b.originalType=e,b.mdxType="string"==typeof e?e:n,c[1]=b;for(var p=2;p<i;p++)c[p]=a[p];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);