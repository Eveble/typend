import { types } from './types';
import { $PropsOf, $TypeOf } from './utility-types';
import * as METADATA_KEYS from './constants/metadata-keys';
import * as LITERAL_KEYS from './constants/literal-keys';
import { internal } from './annotations/internal';
import { Validable } from './annotations/validable';
import { Type } from './decorators/type.decorator';
import { ValidationError, InvalidDefinitionError, InvalidTypeError, InvalidValueError, UnequalValueError, UnmatchedTypeError, NotAMemberError, UnexpectedKeyError, UnknownError, TypeDescriberExistsError, TypeDescriberNotFoundError, PatternValidatorExistError, PatternValidatorNotFoundError, UndefinableClassError, TypeConverterExists } from './errors';
import { Any } from './patterns/any';
import { Class } from './patterns/class';
import { Collection } from './patterns/collection';
import { CollectionIncluding } from './patterns/collection-including';
import { CollectionWithin } from './patterns/collection-within';
import { Equals } from './patterns/equals';
import { InstanceOf } from './patterns/instance-of';
import { Integer } from './patterns/integer';
import { Interface } from './patterns/interface';
import { Internal } from './patterns/internal';
import { List } from './patterns/list';
import { LocaleString } from './patterns/locale-string';
import { Maybe } from './patterns/maybe';
import { Never } from './patterns/never';
import { OneOf } from './patterns/one-of';
import { Optional } from './patterns/optional';
import { Tuple } from './patterns/tuple';
import { Unknown } from './patterns/unknown';
import { Void } from './patterns/void';
import { Where } from './patterns/where';
import { Unrecognized } from './patterns/unrecognized';
import { WrapperPattern } from './wrapper-pattern';
import { PropsOf } from './utilities/props-of';
import { TypeOf } from './utilities/type-of';
import { AnyValidator } from './validators/any-validator';
import { ClassValidator } from './validators/class-validator';
import { CollectionIncludingValidator } from './validators/collection-including-validator';
import { CollectionWithinValidator } from './validators/collection-within-validator';
import { CollectionValidator } from './validators/collection-validator';
import { EqualsValidator } from './validators/equals-validator';
import { InstanceOfValidator } from './validators/instance-of-validator';
import { IntegerValidator } from './validators/integer-validator';
import { InterfaceValidator } from './validators/interface-validator';
import { InternalValidator } from './validators/internal-validator';
import { ListValidator } from './validators/list-validator';
import { LocaleStringValidator } from './validators/locale-string-validator';
import { MaybeValidator } from './validators/maybe-validator';
import { NeverValidator } from './validators/never-validator';
import { OneOfValidator } from './validators/one-of-validator';
import { OptionalValidator } from './validators/optional-validator';
import { TupleValidator } from './validators/tuple-validator';
import { UnknownValidator } from './validators/unknown-validator';
import { VoidValidator } from './validators/void-validator';
import { WhereValidator } from './validators/where-validator';
import { UnrecognizedValidator } from './validators/unrecognized-validator';
import { ArrayDescriber } from './describers/array-describer';
import { ErrorDescriber } from './describers/error-describer';
import { NativeTypeDescriber } from './describers/native-type-describer';
import { ObjectDescriber } from './describers/object-describer';
import { CompactDescriber } from './describers/compact-describer';
import { ClassDescriber } from './describers/class-describer';
import { FallbackDescriber } from './describers/fallback-describer';
import { DescriptionListDescriber } from './describers/description-list-describer';
import { DebugDescriber } from './describers/debug-describer';
import { PropsOfConverter } from './converters/tsruntime/validation-converters/props-of-converter';
import { TypeOfConverter } from './converters/tsruntime/validation-converters/type-of-converter';
import { AnyConverter } from './converters/tsruntime/type-converters/any.converter';
import { StringConverter } from './converters/tsruntime/type-converters/string.converter';
import { NumberConverter } from './converters/tsruntime/type-converters/number.converter';
import { BooleanConverter } from './converters/tsruntime/type-converters/boolean.converter';
import { StringLiteralConverter } from './converters/tsruntime/type-converters/string-literal.converter';
import { NumberLiteralConverter } from './converters/tsruntime/type-converters/number-literal.converter';
import { FalseLiteralConverter } from './converters/tsruntime/type-converters/false-literal.converter';
import { TrueLiteralConverter } from './converters/tsruntime/type-converters/true-literal.converter';
import { EnumLiteralConverter } from './converters/tsruntime/type-converters/enum-literal.converter';
import { ESSymbolConverter } from './converters/tsruntime/type-converters/essymbol.converter';
import { VoidConverter } from './converters/tsruntime/type-converters/void.converter';
import { NullConverter } from './converters/tsruntime/type-converters/null.converter';
import { UndefinedConverter } from './converters/tsruntime/type-converters/undefined.converter';
import { NeverConverter } from './converters/tsruntime/type-converters/never.converter';
import { TupleConverter } from './converters/tsruntime/type-converters/tuple.converter';
import { UnionConverter } from './converters/tsruntime/type-converters/union.converter';
import { ReferenceConverter } from './converters/tsruntime/type-converters/reference.converter';
import { ClassConverter } from './converters/tsruntime/type-converters/class.converter';
import { UnknownConverter } from './converters/tsruntime/type-converters/unknown.converter';
import { FunctionConverter } from './converters/tsruntime/type-converters/function.converter';
import { ArrayConverter } from './converters/tsruntime/type-converters/array.converter';
import { TSRuntimeConverter } from './converters/tsruntime/tsruntime-converter';
import { InjectingPropsTransformer } from './converters/transformers/injecting-props-transformer';
import { InternalPropsTransformer } from './converters/transformers/internal-props-transformer';
import { Typend } from './typend';
import { Validator } from './validator';
import { Describer } from './describer';
import { Description, DescriptionList } from './description';
import { Pattern } from './pattern';
import { PatternValidator } from './pattern-validator';
import { isInstanceOfExpectation, getResolvablePath, isResolvablePath, isPatternClass, isPattern, isUtility, isType, isValidable, getMatchingParentProto, isSpecial } from './helpers';
import { equivalentClassChai } from './chai/equivalent-class.chai-plugin';
declare const describer: types.Describer;
declare const converter: types.Converter;
declare const validator: types.Validator;
declare const typend: types.Library;
declare const validate: any;
declare const isValid: any;
declare const isInstanceOf: any;
declare const check: import("tsruntime").MarkReflective<(<T>(value: any, isStrict?: boolean) => boolean)>;
declare const is: import("tsruntime").MarkReflective<(<T>(value: any, isStrict?: boolean) => boolean)>;
declare const instanceOf: import("tsruntime").MarkReflective<(<T>(value: any) => boolean)>;
declare const convert: import("tsruntime").MarkReflective<(<T>() => any)>;
declare const reflect: import("tsruntime").MarkReflective<(<T>() => any)>;
declare const any: Any;
declare const never: Never;
declare const voided: Void;
declare const unknown: Unknown;
declare function collection(properties: Record<keyof any, any>): Collection;
declare function collectionIncluding(properties: Record<keyof any, any>): CollectionIncluding;
declare function collectionWithin(properties: Record<keyof any, any>): CollectionWithin;
declare function list(...expectations: any[]): List;
declare function maybe(expectation: any): Maybe;
declare function oneOf(...expectations: any[]): OneOf;
declare function optional(expectation: any): Optional;
declare function tuple(...expectations: any[]): Tuple;
declare function unrecognized(expectation?: any): Unrecognized;
declare function where(fn: Function): Where;
declare function eq(expectation: any): Equals;
declare function iof(type: any): InstanceOf;
declare function propsOf(type: types.Class): PropsOf;
declare function typeOf(type: types.Class): TypeOf;
declare const string: Function;
declare const number: Function;
declare const boolean: Function;
declare const symbol: Function;
declare const PropTypes: {
    any: Any;
    array: ArrayConstructor;
    arrayOf: typeof list;
    bool: BooleanConstructor;
    func: FunctionConstructor;
    equal: typeof eq;
    instanceOf: typeof iof;
    integer: typeof Integer;
    interface(properties: Record<keyof any, any>): Interface;
    maybe: typeof maybe;
    never: Never;
    number: NumberConstructor;
    object: Collection;
    objectOf: (_props: any) => Collection;
    oneOf: (expectations: any[]) => OneOf;
    oneOfType: (expectations: any[]) => OneOf;
    shape(properties: Record<keyof any, any>): Collection;
    string: StringConstructor;
    symbol: SymbolConstructor;
    tuple: typeof tuple;
    void: Void;
    where: typeof where;
};
export { types, $PropsOf, $TypeOf, METADATA_KEYS, LITERAL_KEYS, ValidationError, InvalidDefinitionError, InvalidTypeError, InvalidValueError, UnequalValueError, UnmatchedTypeError, NotAMemberError, UnexpectedKeyError, UnknownError, TypeDescriberExistsError, TypeDescriberNotFoundError, PatternValidatorExistError, PatternValidatorNotFoundError, UndefinableClassError, TypeConverterExists, Any, Class, Collection, CollectionIncluding, CollectionWithin, Equals, InstanceOf, Integer, Interface, Internal, List, LocaleString, Maybe, Never, OneOf, Optional, Tuple, Unknown, Unrecognized, Void, Where, WrapperPattern, PropsOf, TypeOf, AnyValidator, ClassValidator, CollectionIncludingValidator, CollectionWithinValidator, CollectionValidator, EqualsValidator, InstanceOfValidator, IntegerValidator, InterfaceValidator, InternalValidator, ListValidator, LocaleStringValidator, MaybeValidator, NeverValidator, OneOfValidator, OptionalValidator, TupleValidator, UnknownValidator, UnrecognizedValidator, VoidValidator, WhereValidator, ArrayDescriber, ErrorDescriber, NativeTypeDescriber, ObjectDescriber, CompactDescriber, ClassDescriber, FallbackDescriber, DescriptionListDescriber, DebugDescriber, AnyConverter, StringConverter, NumberConverter, BooleanConverter, StringLiteralConverter, NumberLiteralConverter, FalseLiteralConverter, TrueLiteralConverter, EnumLiteralConverter, ESSymbolConverter, VoidConverter, NullConverter, UndefinedConverter, NeverConverter, TupleConverter, UnionConverter, ReferenceConverter, ClassConverter, UnknownConverter, FunctionConverter, ArrayConverter, PropsOfConverter, TypeOfConverter, TSRuntimeConverter, InjectingPropsTransformer, InternalPropsTransformer, Typend, Validator, Describer, Description, DescriptionList, Pattern, PatternValidator, getResolvablePath, isInstanceOfExpectation, isResolvablePath, isPatternClass, isPattern, isUtility, isType, isValidable, getMatchingParentProto, isSpecial, typend, validator, describer, converter, validate, isValid, isInstanceOf, check, is, instanceOf, convert, reflect, internal, Validable, Type, any, iof, collection, collectionIncluding, collectionWithin, eq, Integer as integer, list, maybe, never, oneOf, optional, tuple, unknown, unrecognized, voided, where, PropTypes, propsOf, typeOf, string, number, boolean, symbol, equivalentClassChai, };
